import streamlit as st
import sqlite3
import base64
import requests
import random
import time
import os
from FraudDetection import FraudDetectionApp  # Ensure this module is available and implemented

st.title("Welcome to the Multi-Domain Fraud Detection System")
st.markdown(
        f"""
        <style>
        [data-testid="stSidebar"] {{
            background-color: {"#a699b2"};
            color: {"#FFFFFF"};
        }}
        </style>
        """,
        unsafe_allow_html=True
)

st.image("Images/coverpage.png")
st.markdown("""


Our innovative platform integrates advanced AI and machine learning techniques to address three critical areas of fraud detection: **GPT-Generated Text Detection**, **Credit Card Fraud Detection**, and **Automobile Fraud Detection**. Each domain is tackled using state-of-the-art models and algorithms, ensuring accurate predictions and real-time fraud prevention.

---

## Overview of the System

Fraud detection has become a critical challenge in today's digital age. With the rise of artificial intelligence and the internet, fraudulent activities have taken new and complex forms. This application serves as a multi-domain fraud detection hub, empowering users to identify and mitigate risks effectively.

### Key Features of the System
1. **GPT-Generated Text Detection**:
    - Identifies AI-generated content by analyzing text perplexity and patterns.
    - Ensures the authenticity of textual data for academic, legal, and creative applications.

2. **Credit Card Fraud Detection**:
    - Leverages a deep learning model (ANN) trained on financial transaction data.
    - Accurately predicts fraudulent transactions, reducing financial losses.

3. **Automobile Fraud Detection**:
    - Uses supervised learning and label encoding for fraud analysis in automobile insurance claims.
    - Detects anomalies in user inputs like vehicle category, accident area, and claim history.

---

## 1. GPT-Generated Text Detection

### The Challenge
With the advent of large language models such as GPT, distinguishing between human-written and AI-generated text has become increasingly difficult. Malicious actors might use AI-generated content for misinformation, academic dishonesty, or plagiarism. Detecting such content is vital for maintaining trust and integrity in various domains.

### Our Solution
This module employs perplexity-based analysis to evaluate whether a given piece of text is likely generated by an AI. Perplexity measures how predictable a sequence of words is, providing a strong indicator of machine-generated text. Text generated by GPT models typically exhibits lower perplexity due to their statistical nature.

### How It Works
1. **User Input**: Upload or paste a block of text for analysis.
2. **Perplexity Calculation**: The system calculates perplexity scores for the text.
3. **Prediction**: Based on thresholds, the model determines whether the text is human-written or AI-generated.
4. **Output**: A clear, actionable result is displayed, highlighting areas of concern if AI involvement is suspected.

### Use Cases
- **Academic Research**: Validate the authenticity of research papers and assignments.
- **Content Creation**: Ensure originality in creative and journalistic work.
- **Legal Compliance**: Detect and prevent misuse of AI-generated content in sensitive documents.

---

## 2. Credit Card Fraud Detection

### The Challenge
Credit card fraud is one of the most prevalent forms of financial crime, resulting in billions of dollars in losses annually. Traditional methods of fraud detection often struggle to keep up with sophisticated schemes.

### Our Solution
Using a trained Artificial Neural Network (ANN) model, this module identifies patterns in transaction data to flag potentially fraudulent activities. By analyzing features such as transaction amount, location, and time, the system provides accurate predictions and actionable insights.

### How It Works
1. **Data Upload**: Users upload a CSV file containing transaction data.
2. **Feature Analysis**: The model analyzes features and extracts patterns indicative of fraud.
3. **Prediction**: The ANN model classifies each transaction as either "Normal" or "Fraudulent."
4. **Output**: Results are presented in a detailed table, highlighting fraudulent cases for further action.

### Key Benefits
- **Accuracy**: High detection rates with minimal false positives.
- **Scalability**: Handles large datasets, making it suitable for financial institutions.
- **Proactive Fraud Prevention**: Enables real-time alerts and decision-making.

### Use Cases
- **Banking and Finance**: Protect customers from unauthorized transactions.
- **E-commerce Platforms**: Safeguard online payments against fraudulent activities.
- **Credit Card Companies**: Enhance customer trust with robust fraud detection mechanisms.

---

## 3. Automobile Fraud Detection

### The Challenge
Automobile insurance fraud is a growing concern, costing insurers millions annually. Fraudulent claims often involve fabricated or exaggerated damages, false accidents, or misrepresented information.

### Our Solution
This module uses supervised learning models to analyze claims and identify potential fraud. By leveraging historical data and user-provided inputs, the system detects anomalies and flags suspicious cases for further review.

### How It Works
1. **Input Collection**: Users input details about the claim, such as:
    - Vehicle category
    - Accident area
    - Age of the policyholder
    - Policy type and coverage details
2. **Feature Transformation**: Categorical data is encoded using pre-trained label encoders.
3. **Prediction**: The machine learning model analyzes the input and predicts whether the claim is likely fraudulent.
4. **Output**: Results are displayed in an intuitive format, with clear indicators of fraud risk.

### Key Benefits
- **Enhanced Accuracy**: Models trained on diverse datasets provide reliable predictions.
- **Customizable Inputs**: Users can modify parameters to test different scenarios.
- **Fraud Mitigation**: Early detection helps prevent payouts for fraudulent claims.

### Use Cases
- **Insurance Companies**: Streamline claim processing by identifying fraud early.
- **Law Enforcement**: Investigate patterns in fraudulent claims to uncover organized crime.
- **Vehicle Owners**: Protect against fraudulent claims that could impact premiums.

---

## Technologies Used

### Machine Learning Models
- **Artificial Neural Networks (ANN)**: Used for credit card fraud detection, leveraging deep learning to identify complex patterns.
- **Supervised Learning**: Employed in automobile fraud detection to classify claims as legitimate or fraudulent.
- **Perplexity Analysis**: Applied in GPT-generated text detection for analyzing text patterns.

### Data Processing Tools
- **Pandas and NumPy**: For handling large datasets and preprocessing.
- **Joblib and Pickle**: For model serialization and deserialization.
- **Streamlit**: Provides an intuitive web-based interface for users.

---

## Future Enhancements

### GPT-Generated Text Detection
- **Expanded Scope**: Incorporate detection for other AI-generated media, such as images or videos.
- **Improved Models**: Use advanced AI explainability tools for greater transparency.

### Credit Card Fraud Detection
- **Real-Time Processing**: Enable real-time transaction monitoring.
- **Global Integration**: Support for multi-currency datasets and international transactions.

### Automobile Fraud Detection
- **Telematics Integration**: Utilize IoT data from vehicles for enhanced fraud detection.
- **Policy Recommendations**: Provide insights to insurers for better policy structuring.

""")

class UserAuthApp:
    def __init__(self):
        self.init_db()
        self.TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "7501242677:AAEr_IF4AlsU1xqWI041UQyNDfB2sGrEp7c")
        self.TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "903868226")

        # Initialize session state variables
        if "random_number" not in st.session_state:
            st.session_state.random_number = None
        if "start_time" not in st.session_state:
            st.session_state.start_time = None
        if "timer_running" not in st.session_state:
            st.session_state.timer_running = False
        if "is_code_expired" not in st.session_state:
            st.session_state.is_code_expired = False
        if "logged_in" not in st.session_state:
            st.session_state.logged_in = False
        if "username" not in st.session_state:
            st.session_state.username = None

    def init_db(self):
        """Initialize the SQLite database."""
        conn = sqlite3.connect("users.db")
        c = conn.cursor()
        c.execute("""
            CREATE TABLE IF NOT EXISTS users (
                username TEXT UNIQUE,
                name TEXT,
                last_name TEXT,
                email TEXT UNIQUE,
                location TEXT
            )
        """)
        conn.commit()
        conn.close()

    def register_user(self, username, name, last_name, email, location):
        """Register a new user in the database."""
        conn = sqlite3.connect("users.db")
        c = conn.cursor()
        try:
            c.execute("""
                INSERT INTO users (username, name, last_name, email, location)
                VALUES (?, ?, ?, ?, ?)
            """, (username, name, last_name, email, location))
            conn.commit()
        except sqlite3.IntegrityError as e:
            conn.close()
            if "UNIQUE constraint failed" in str(e):
                if "username" in str(e):
                    return "Username already exists."
                elif "email" in str(e):
                    return "Email already registered."
            return "Registration failed."
        conn.close()
        return "Success"

    def authenticate_user(self, username):
        """Check if the username exists in the database."""
        conn = sqlite3.connect("users.db")
        c = conn.cursor()
        c.execute("SELECT * FROM users WHERE username = ?", (username,))
        user = c.fetchone()
        conn.close()
        return user is not None

    def send_otp_to_telegram(self):
        """Generate and send an OTP to the user's Telegram."""
        st.session_state.random_number = random.randint(1000, 9999)
        st.session_state.start_time = time.time()
        st.session_state.timer_running = True
        st.session_state.is_code_expired = False
        message = f"Your authentication code is: {st.session_state.random_number}"
        url = f"https://api.telegram.org/bot{self.TELEGRAM_TOKEN}/sendMessage"
        payload = {"chat_id": self.TELEGRAM_CHAT_ID, "text": message}
        response = requests.post(url, data=payload)
        if response.status_code == 200:
            st.sidebar.success("Authentication code sent to your Telegram!")
        else:
            st.sidebar.error("Failed to send authentication code to Telegram. Please try again.")

    def authenticate_with_otp(self, entered_number):
        """Validate the entered OTP."""
        if st.session_state.is_code_expired:
            st.sidebar.error("The authentication code has expired. Please generate a new code.")
            return False
        if not st.session_state.random_number or not st.session_state.start_time:
            st.sidebar.error("Please generate and send the code first!")
            return False
        elapsed_time = time.time() - st.session_state.start_time
        if elapsed_time > 30:
            st.sidebar.error("Time expired! Please request a new authentication code.")
            st.session_state.is_code_expired = True
            st.session_state.timer_running = False
            return False
        if entered_number == st.session_state.random_number:
            st.sidebar.success("Authentication successful! Welcome!")
            st.session_state.timer_running = False
            return True
        else:
            st.sidebar.error("Invalid authentication code.")
            return False

    def clear_window_for_fraud_detection(self):
        """Clear the Streamlit window to display the FraudDetectionApp."""
        st.markdown(
            """
            <style>
            .stApp {{
                background-image: none;
                background-color: white;
            }}
            [data-testid="stSidebar"] {{
                display: none;
            }}
            </style>
            """,
            unsafe_allow_html=True
        )
        st.empty()  # Clear any other UI elements

    def register_ui(self):
        """UI for user registration."""
        st.sidebar.subheader("Create New Account")
        name = st.sidebar.text_input("First Name")
        last_name = st.sidebar.text_input("Last Name")
        email = st.sidebar.text_input("Email")
        location = st.sidebar.text_input("Location")
        new_username = st.sidebar.text_input("Username")

        if st.sidebar.button("Register"):
            registration_result = self.register_user(new_username, name, last_name, email, location)
            if registration_result == "Success":
                st.sidebar.success("Account created successfully! You can now log in with OTP.")
            else:
                st.sidebar.error(registration_result)

    def login_ui(self):
        """UI for OTP-based login."""
        st.sidebar.subheader("Login with OTP")
        username = st.sidebar.text_input("Username")
        if st.sidebar.button("Send OTP"):
            if self.authenticate_user(username):
                self.send_otp_to_telegram()
            else:
                st.sidebar.error("Invalid username")

        if st.session_state.timer_running:
            elapsed_time = time.time() - st.session_state.start_time
            remaining_time = max(0, 30 - elapsed_time)
            st.sidebar.write(f"Time remaining to enter the code: **{int(remaining_time)} seconds**")
            if remaining_time == 0:
                st.session_state.timer_running = False
                st.session_state.is_code_expired = True

        entered_code = st.sidebar.text_input("Enter the OTP sent to Telegram:", type="password")
        if st.sidebar.button("Authenticate"):
            if entered_code.isdigit():
                if self.authenticate_with_otp(int(entered_code)):
                    st.session_state['logged_in'] = True
                    st.session_state['username'] = username
                    st.sidebar.success(f"Welcome {username}!")
                    self.clear_window_for_fraud_detection()  # Clear UI and remove background/sidebar
                    app = FraudDetectionApp()  # Launch FraudDetectionApp
                    app.run()
            else:
                st.sidebar.error("Invalid OTP")

    def main(self):
        """Main application logic."""
        if not st.session_state.logged_in:
            st.sidebar.title("User Authentication System")
            menu = ["Register", "OTP Login"]
            choice = st.sidebar.radio("Select an Option", menu)

            if choice == "Register":
                self.register_ui()
            elif choice == "OTP Login":
                self.login_ui()
        else:
            # If logged in, clear the interface for the FraudDetectionApp
            self.clear_window_for_fraud_detection()
            app = FraudDetectionApp()
            app.run()


if __name__ == '__main__':
    app = UserAuthApp()
    app.main()
